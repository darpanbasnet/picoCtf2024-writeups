# Heap0: An Easy Binary Exploitation Challenge in PicoCTF 2024

![Heap0 Description](https://github.com/user-attachments/assets/5f860e66-a2b9-4143-9a5e-aaa735f2c724)

In this binary exploitation challenge, we aim to find a vulnerability within a provided heap-based program. Let's dive into the process of solving this step-by-step.

---

### Steps to Approach

1. **Download the Source Code**  
   Begin by examining the source code, focusing on memory-related operations within functions to spot vulnerabilities in heap management.

2. **Launch the Instance**  
   Connect to the instance to interact with the challenge environment.

   ![Connect to the instance](https://github.com/user-attachments/assets/8db3f16d-a329-476f-a92e-c61ae3e98d88)

### Code Analysis

As we analyze the source code, we come across a function named **`void check_win()`**, which is central to the challenge:

![void check_win() function](https://github.com/user-attachments/assets/22a537c4-ba09-4e3c-9403-db9cf7144657)

In this function, the variable **`safe_var`** is compared with the string `"bico"`. If `strcmp` returns `1` (indicating `safe_var` does **not** match `"bico"`), then the flag is printed. Our goal is to manipulate `safe_var` so it differs from `"bico"` and triggers the flag output.

![bico in safe_var](https://github.com/user-attachments/assets/f830c39b-7227-4b40-a4ca-9180059c4b47)

The `init()` function initializes **`input_data`** to `"pico"` and **`safe_var`** to `"bico"`:

![Initialization in init function](https://github.com/user-attachments/assets/9d409f70-e203-4a7d-972e-dbc701aa99b2)

### Identifying the Vulnerability

Another function, **`write_buffer()`**, allows us to write data into `input_data` using `scanf`. Since `scanf` lacks boundary checks, it can overwrite memory beyond the allocated space for `input_data`, creating a buffer overflow vulnerability. By overflowing `input_data`, we can reach and modify `safe_var`, which is stored directly after `input_data` on the heap.

![Memory Layout](https://github.com/user-attachments/assets/f830c39b-7227-4b40-a4ca-9180059c4b47)

### Memory Offset Calculation

From our memory inspection, we see:
- **`input_data`** is located at **0x623d20a682b0**
- **`safe_var`** is located at **0x623d20a682d0**

The offset between them is:
**0x623d20a682d0 - 0x623d20a682b0 = 32 bytes**

Thus, if we enter more than 32 bytes into `input_data`, we can overwrite `safe_var`.

### Exploiting the Overflow

To achieve the overflow, we input 32 filler characters followed by a unique value (like `1000`) to replace `"bico"` in `safe_var`. This successfully alters `safe_var` and causes `strcmp` to return `1`, revealing the flag.

![Exploitation and flag retrieval](https://github.com/user-attachments/assets/eddc269a-cb5d-41fe-af41-831609ff35fa)

Here, our input successfully overwrites `safe_var`, triggering the `check_win()` function and displaying the flag.

![Flag](https://github.com/user-attachments/assets/12332a74-451c-4d73-ac4c-903a6e931da5)


By understanding and leveraging buffer overflow techniques, we bypassed the program's checks and retrieved the flag. This is a fundamental technique in heap exploitation

*Note:* **We will use the same method for Heap1**
